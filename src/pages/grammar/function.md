## 概述

函数就是一段可以反复调用的代码块，函数还能接受输入的参数，使不同函数返回不同的值等。

#### 声明

**function 命令**

`function`命令声明的代码区块，就是一个函数。命令后跟函数名，参数，函数体。

```
function print() {};
```

命名定义一个函数，叫做函数的声明。

**函数表达式**

可以采用变量赋值方法声明函数

```
var print = function() {};
```

将一个匿名函数赋值给变量，这时的匿名函数称为函数表达式。采用这种方式时function后面如果加上函数名，则只在函数体内部有效。

**Function 构造函数**

var add = new Function(
  'x',
  'y',
  'return (x + y)'
);

Function构造函数接受n个参数，其中最后一个为函数体，之前的均为函数参数。

#### 重复声明

如果一个函数被多次声明，最后的会覆盖前者。

#### 圆括号运算符，return语句与递归

调用函数时要使用圆括号运算符，其中可以加入函数的参数。

函数体中的return语句表示返回，其后及时有语句也不会执行。如果没有该语句默认返回undefined。

函数可以调用自身，这就是递归。

#### 函数名的提升

js将函数看做一种值，与原始类型的的值地位相同，可以使用值的地方都可以使用函数。

js引擎将函数名视为变量名，采用function声明函数时，这个函数会像变量声明一样被提升到代码头部。但是在使用函数表达式声明时由于将变量赋值为函数是后执行的，先调用函数就会报错。

```
f();
var f = function (){};
// TypeError: undefined is not a function

// 相当于
var f;
f();
f = function () {};
```

#### 条件语句与函数

不应该在条件语句中使用function命令声明函数，会遇到和变量一样的问题。想要达到在条件语句中定义函数的目的，只用使用函数表达式。

## 函数的属性与方法

* **name属性** 返回紧跟在function关键词之后的函数名。
* **length属性** 返回在函数定义中的参数个数。
* **toString方法** 返回函数的源码,内部的注释也返回。

## 函数作用域

作用域指变量存在的范围，js只有两种作用域，一种全局作用域，一种函数作用域，其变量分别称为全局与局部变量。

* 局部变量外部无法读取。
* 局部变量会在其作用域内覆盖同名全局变量。
* 函数作用域中也会产生变量提升现象。
* 函数作用域是局部变量声明时所在的作用域，与其运行时所在的作用域无关。

## 参数

函数运行时，有时需要提供外部数据，即参数。

* 参数不是必须的，允许省略参数。
* 参数可以通过es6的初始赋值或“或运算”设置默认值。
* 参数为原始类型的值为传值传递，在函数内修改参数值不会影响到函数外部。复合类型的值为传址传递，修改时会影响到原始值。但如果不是修改参数的某个属性，而是整个替换调参数，不会影响到原始值。
* 如果有同名的参数，则取最后出现的那个值

#### arguments对象

每个函数体内有arguments对象，包含了函数运行时的所有参数（按照类数组对象方式读取），除了可以读取还可以给参数赋值（严格模式不允许），通过其length属性判断函数调用时带有几个参数。

arguments为类数组对象，可以使用Array.prototype.slice.call(arguments)转化为真正的数组。

arguments带有一个callee属性，返回它对应的原函数。

## 闭包

处于种种原因，可能需要得到函数内的局部变量，可以通过在函数内部再定义一个函数解决。

```
function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999
```

闭包就是函数f2，即能读取其他函数内部变量的函数，其用处有两个，读取函数内部变量和让这些变量始终保存在内存中。

```
function createIncrementor(start) {
  return function () {
    return start++;
  };
}

var inc = createIncrementor(5);

inc() // 5
inc() // 6
inc() // 7
```

因为如此，闭包可以用来封装对象的私有属性和方法。

```
function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
```

## 立即调用函数表达式

当function关键式出现在行首时会被引擎理解为语句，必须按照函数定义来书写，不是行首时理解为表达式。需要写立即调用函数表达式时可以在function语句两端加括号，引擎会将其理解为一个表达式，之后用圆括号表达式执行函数。

## eval命令

其作用为将字符串当做语句执行。eval没有自己的作用域，在当前作用域内执行，可能修改当前作用域变量的值，造成安全问题。如果使用严格模式，则eval内部声明的变量不会影响外部作用域，但仍然可以读写外部作用域变量

在直接调用时eval的作用域为当前作用域，在间接调用时则为全局作用域（规范中的定义）。

与eval作用类似的还有Function构造函数，利用它生成并调用函数，也能将字符串当做命令执行。
